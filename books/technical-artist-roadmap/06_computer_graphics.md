---
title: "基礎知識：コンピューターグラフィックス（執筆中：60%）"
emoji: "💎"
published: true
---
    
コンピューターグラフィックスとは、計算機で画像を生成・操作・出力するための技術の分野のことです。CGと略します。ここでは主に3DCGの知識に限定してまとめていきます。


# 3Dモデルのデータ形式


## ポリゴン


ポリゴンは、3D空間における物体の表面を、多角形（主に三角形）の集合として表現するデータ形式です。これらの三角形を多数組み合わせて、複雑な形状を作り出すことができます。


![image.png](/images/books/tar/computer_graphics_1.png)




１ポリゴンに３つの頂点（vertices）があります。またそれぞれの頂点には順番（indices）があり、その順番によって、ポリゴンの裏と表を表現します。（0,1,2の回転で右ネジの進行方向が表）


まてそれぞれの頂点には、UV座標や頂点カラー、スキンウェイトなどの情報をもたせることができ、テクスチャやスキニングなどの表現に応用することができます。


### リアルタイムポリゴンレンダリングの仕組み


ここで、リアルタイムグラフィックスにおける、ポリゴンレンダリングの仕組みを流れに沿って説明します。

1. 頂点とポリゴンの情報をまとめて頂点バッファとしてGPUに送られる。
2. 送られた情報を元に頂点シェーダーは、3次元情報であるポリゴンを、画面である2次元の座標に変形させます。
3. 次に、ポリゴンたちを画面上のピクセルごとに処理をできるようにフラグメント処理がされます。ここで色や透明度などが決定されます。
4. 最後にデプステスト（Zバッファテスト）やブレンディングといった処理が行われ、最終的なピクセルの色がフレームバッファ（出力画像）に書き込まれます。

## 点群・ポイントクラウド


ポイントクラウドは、3D空間内の点の集合体です。基本的に位置情報（XYZ座標）が含まれます。色や強度などの追加情報を持つこともあります。


フォトグラメトリーやレーザースキャナーなどを使った、現実世界の3次元スキャンなどでよく使われるデータ形式です。


![image.png](/images/books/tar/computer_graphics_2.png)




## NURBS(Non-Uniform Rational B-Spline)


NURBSは、滑らかな曲線や曲面を数学的に表現する方法です。非常に滑らかで正確な形状を作ることができ、形状の変更や編集が容易です。ポリゴンモデリングとは異なり、NURBSは数学的に連続な関数で記述されるため、無限に表面を分割できます。


![image.png](/images/books/tar/computer_graphics_3.png)




### B-Spline


B-Splineは曲線をいくつかの点だけで表現できる、数学的な関数です。NURBSはこのB-Splineを基本要素として、立体の情報を持つことができます。


B-Splineは以下の基本要素で構成されています。

- **コントロールポイント**: 曲線や曲面の形状を決定する点のセットです。これらのポイントを動かすことで、曲線や曲面の形状を直接的に調整することができます。
- **ノットベクトル**: 曲線や曲面を部分的に定義する数値の配列です。ノットベクトルによって、曲線や曲面の滑らかさや分割の仕方が決定されます。

## ボリューム


ボリュームデータは、空間の粗密を表現できるデータ形式です。主に、煙や雲や炎などの表現や、。これは、ボクセル（3Dピクセル）として知られる小さな立方体の格子の集合で構成されています。ボリュームデータは、物質の内部の密度（Density）や色など、追加的な情報を格納することができます。


![image.png](/images/books/tar/computer_graphics_4.png)




# カメラ・プロジェクション


３次元空間の座標を2次元平面に投影する方法です。これによって、3次元の表現をディスプレイなどの画面に表現することができます。


具体的には、３つの行列（**モデル行列**と**ビュー行列**と**プロジェクション行列**）を使って、現実のカメラや目の挙動をシュミレートする計算をすることになります。


![image.png](/images/books/tar/computer_graphics_5.png =480x)




**ビュー行列**とは、カメラの位置・回転を表した4x4の行列の逆行列です。


また**モデル行列**は、３次元空間での位置、回転、拡縮を表した4x4の行列になります。


これらの、モデル行列とビュー行列をかけることによって、カメラの位置を原点とみなした座標系に変換することができます。これらを外部パラメーターといいます。


**プロジェクション行列**は、カメラの画角や奥行きの範囲を表すような視錐台(View Frsutum)を表した行列になります。またこれらを内部パラメーターといいます。


この視錐台は、垂直視野角、水平視野角（またはアス比）、最前面までの距離（Near）、最奥面までの距離（Far）の４つのパラメーターから成り立っています。


## 投影方法によるプロジェクション行列の違い


### **透視投影**


透視投影は、3D空間のオブジェクトを2Dスクリーンに投影する際の変換行列で、次のような式で表されます。


$$
P = \begin{pmatrix}
\frac{2 z_{near}}{w} & 0 & 0 & 0 \\
0 & \frac{2 z_{near}}{h} & 0 & 0 \\
0 & 0 & \frac{-z_{far} + z_{near}}{z_{far} - z_{near}} & \frac{-2 z_{far} z_{near}}{z_{far} - z_{near}} \\
0 & 0 & -1 & 0
\end{pmatrix}
$$


ここで、`w` と `h` はスクリーンの幅と高さ、`z_{near}` と `z_{far}` は近くと遠くのクリップ平面の距離を示します。透視投影行列は、視野の歪みや奥行きの遠近感を反映します。


### **平行投影**


平行投影は、視点の影響を受けず、物体の大きさが距離によって変わらない投影方法です。数式は次のようになります。


	$$
	P = \begin{pmatrix}
	\frac{2}{right - left} & 0 & 0 & \frac{right + left}{right - left} \\
	0 & \frac{2}{top - bottom} & 0 & \frac{top + bottom}{top - bottom} \\
	0 & 0 & \frac{-2}{z_{far} - z_{near}} & \frac{z_{far} + z_{near}}{z_{far} - z_{near}} \\
	0 & 0 & 0 & 1
	\end{pmatrix}
	$$


	ここで、`right`, `left`, `top`, `bottom` は投影範囲の座標で、`z_{near}` と `z_{far}` は近くと遠くのクリップ平面の距離です。


これらの行列は、3Dの視点からの変換を定義するために使用されます。透視投影は遠くのオブジェクトを小さく、近くのオブジェクトを大きくする効果がありますが、平行投影ではそのような効果はなく、オブジェクトのサイズはその位置に関係なく一定です。


### 平行投影


# レンダリング


3Dモデルの色を決定するプロセスに、ライティング（照明）とシェーディング（陰影）があります。それぞれ使われているロジックが違いますが、後述のレンダリングでとりまとめて、絵を出力することができます。


## ライティング


ライティングとは、CGシーン内の物体に光を当てて、物体の色に影響を与える手法になります。


現実のライト（照明）をCGで計算しやすいようにモデル化したものを使用し、レンダリング方法によって、使われるライトに違いがあります。

- **アンビエントライト（環境光）**:シーン全体に均一に影響を与える光です。影が少なく、ディテールが見えにくくなります。
- **ディレクショナルライト（平行光源）**:太陽光のように無限遠から平行に届く光です。１つのベクトルによって表現でき、軽量な計算ができるのが特徴です。
- **ポイントライト（点光源）**: 電球のような一点の位置から全方向に放射される光で、位置と効果範囲（距離減衰 attenuation）によって表現されます。
- **スポットライト**: 特定の方向に向かって放射される光です。位置と放射角とベクトルによって表現されます。
- **エリアライト**: 面から発せられる光です。より複雑な計算が必要になりますが、現実の照明に近い表現が可能になります。
- **スカイライト：**空全体からの間接光をシミュレート。全天光とも呼ばれる。自然光のシミュレーションに適しています。
- **イメージベースドライティング（IBL）** ：撮影した写真を光源として利用する方法です。より現実の空間照明に近い表現が可能になります。

## シェーディング


シェーディングとは、ポリゴンの色を決定するための陰影を表現する手法です。前述のライティングを用いた光の計算と、物体の表面の性質（パラメーター）を用いて色を決定するプロセスです。

- **フラットシェーディング（Flat Shading）:** ポリゴンの面法線を計算して、そのポリゴンに一様に色を塗るシンプルな方法
- **グーローシェーディング（Gouraud Shading）:**各頂点ごとに色を計算しポリゴンの内部を補完した色で塗る方法。
- **ランバートシェーディング（Lambert Shading）**：拡散反射（ディフューズ反射）のみを考慮し、光が表面に対してどの角度で当たるかに基づいて明るさを計算します。
- **フォンシェーディング（Phong Shading）：** Lambertシェーディングに鏡面成分（テカり）成分を付け加えたモデルになります。
- **ブリンシェーディング（Blinn-Phong Shading）：**フォンシェーディングの改良版で、計算効率が高く、特にリアルタイムレンダリングで広く使用されます。
- **Torrance Spallow モデル**：物理ベースレンダリング（PBR）の一部として使用されるモデルで、光の反射と屈折をより現実的にシミュレートします。

以下では代表的なシェーディングモデルの概要と計算式を示します。


### Lambertモデル


シンプルな陰影計算のモデルで、ディレクショナルライトのベクトルとモデルの法線の内積によって計算されます。


```glsl
// ランバート反射の計算（拡散反射）
float diffuseIntensity = max(dot(normal, lightDir), 0.0);
```


### Phongモデル


PhongモデルはLambertモデルに鏡面成分を追加したモデルになります。


```glsl
# Phongモデルの鏡面成分（Specular)の計算
float NdotL =  max(dot(normalVector, LightDirection), 0.0);
vec3 reflectionVector = normalize(2.0 * nomalVector * NdotL - lightDirection);
float specular = pow( max(dot(reflectionVector, viewVector), 0.0), specPower);
```


## レイマーチング


レイマーチングは、光線を送り出してシーン内のオブジェクトとの交差点を見つけ、光の反射や屈折などの効果を計算する手法です。この方法は、リアルな表現を実現するために使用され、特にリアルタイムレンダリングやシミュレーションにおいて効果的です。


[レイマーチングの使用例と技術的な説明]


## **レイトレーシング**


カメラから出る光線の挙動を追跡（トレース）することによってレンダリングを行う手法です。


物体の反射や屈折、影の生成などをより物理的に正確にシミュレートすることができます。近年のGPUの性能向上により、リアルタイムレイトレーシングも実現可能になってきています。


レイトレーシングの主な計算要素：

- **光線の発射（Ray Generation）**：カメラから各ピクセルに向けて光線（レイ）を発射します。
- **交差判定（Ray Intersection）**：発射された光線とシーン内のオブジェクトとの交差点を計算します。
- **反射・屈折計算**：交差点での材質特性に基づいて、反射光や屈折光の方向を計算します。
- **シャドウレイ**：交差点から光源に向けて光線を発射し、影の判定を行います。

```glsl
// レイトレーシングの基本的な擬似コード
Color TraceRay(Ray ray, int depth) {
    if (depth >= maxDepth) return backgroundColor;
    
    Hit hit = SceneIntersect(ray);
    if (!hit.found) return backgroundColor;
    
    Color color = hit.material.baseColor;
    
    // 反射の計算
    if (hit.material.isReflective) {
        Ray reflectRay = CalculateReflection(ray, hit);
        color += TraceRay(reflectRay, depth + 1);
    }
    
    // 影の計算
    bool inShadow = TraceShadowRay(hit.position, lightPosition);
    if (inShadow) color *= shadowFactor;
    
    return color;
}
```


レイトレーシングの最適化手法：

- **空間分割**：BVH（Bounding Volume Hierarchy）やkd-treeなどを使用して、交差判定の計算を効率化します。
- **早期終了**：影の判定時に最初の交差で計算を終了させるなど、不要な計算を省略します。
- **並列処理**：各ピクセルの計算は独立しているため、GPUを使用した並列処理が効果的です。

近年のリアルタイムレイトレーシングでは、以下のような技術が使用されています：

- **デノイジング**：少ないサンプル数でのレンダリング結果にAIを使用してノイズを除去します。
- **ハイブリッドレンダリング**：従来のラスタライズとレイトレーシングを組み合わせて、効率的な描画を実現します。
- **時間的累積**：フレーム間で情報を再利用し、品質を向上させます。

## パストレーシング


パストレーシングは、レイトレーシングの発展形で、よりフォトリアルな画像を生成するためのレンダリング手法です。光の物理的な振る舞いをより正確にシミュレートし、グローバルイルミネーション、コースティクス、サブサーフェススキャタリング、多重バウンスの光の計算や、物理ベースの材質表現、ソフトシャドウの自然な表現などの複雑な光の相互作用を表現することができます。


### パストレーシングの仕組み


パストレーシングは、レイトレーシングの仕組みに加えて、

- **マルチサンプリング**：モンテカルロ法を利用し各ピクセルに対して複数の光線をサンプリングし、それらの結果を平均化することでノイズを軽減します。
- **より高度な光のシミュレーション**：光がシーン内でどのように拡散し、相互作用するかを追跡します。
- **計算コスト**：大量の光線追跡が必要なため、計算コストが非常に高くなります。

## **フォーワードレンダリング**


フォワードレンダリングは、3Dシーンを描画する最も基本的な手法です。シーン内のオブジェクトを1つずつ処理し、各オブジェクトに対してジオメトリ処理、テクスチャマッピング、ライティング計算などを直接行います。


フォワードレンダリングの主な特徴：

- **直接的な処理**：各オブジェクトに対して、すべてのライティングとシェーディング計算を一度に行います。
- **シンプルな実装**：比較的straightforwardな実装が可能で、小規模なシーンや少数の光源に適しています。
- **制限事項**：多数の光源が存在する場合、各オブジェクトに対して全ての光源の計算を行う必要があるため、パフォーマンスが低下する可能性があります。

```glsl
// フォワードレンダリングの基本的な擬似コード
void main() {
    // 頂点変換
    vec4 worldPos = modelMatrix * vec4(position, 1.0);
    
    // ライティング計算
    vec3 finalColor = vec3(0.0);
    for(int i = 0; i < numLights; i++) {
        finalColor += calculateLighting(worldPos, normal, lightPositions[i]);
    }
    
    // 出力カラーの設定
    FragColor = vec4(finalColor, 1.0);
}
```


## **ディファードレンダリング**


![image.png](/images/books/tar/computer_graphics_6.png =541x)




ディファードレンダリングは、シーン内のジオメトリ、法線、マテリアルなどの情報を一旦Gバッファと呼ばれるバッファに書き込み、その後でライティング計算を行う手法です。これにより、複数のライトを効率的に処理することができ、特に多数の光源が存在するシーンで有効です。また、ポストプロセス効果の適用も容易になります。


ディファードレンダリングの主な特徴と利点：

- **Gバッファ（Geometry Buffer）**：最初のパスで位置、法線、アルベド、ラフネスなどの情報を別々のバッファに格納します。
- **ライティングパス**：Gバッファの情報を使用して、2番目のパスで全てのライティング計算を行います。これにより、ライトごとの計算が効率化されます。
- **メモリ使用**：複数のバッファを必要とするため、メモリ使用量が増加しますが、計算効率は向上します。
- **最適化**：ライトカリングやスクリーンスペースの最適化が容易に実装できます。

```glsl
// ディファードレンダリングの擬似コード
// 1. Geometry Pass
void geometryPass() {
    // 位置情報をGバッファに書き込み
    gPosition = worldPos;
    // 法線情報をGバッファに書き込み
    gNormal = normal;
    // マテリアル情報をGバッファに書き込み
    gAlbedo = albedo;
    gRoughness = roughness;
}

// 2. Lighting Pass
void lightingPass() {
    // Gバッファから情報を読み取り
    vec3 position = texture(gPosition, uv).xyz;
    vec3 normal = texture(gNormal, uv).xyz;
    vec3 albedo = texture(gAlbedo, uv).rgb;
    float roughness = texture(gRoughness, uv).r;
    
    // ライティング計算
    vec3 finalColor = calculateLighting(position, normal, albedo, roughness);
}
```


# Graphics API


これらは、3Dグラフィックスの描画とレンダリングを行うためのAPI（アプリケーションプログラミングインターフェース）であり、特にゲーム開発やリアルタイムでの3Dアプリケーション開発に広く使用されています。OpenGLとDirectXは、以下のような機能を提供します。

- **レンダリングパイプラインの管理**：3Dグラフィックスのレンダリングプロセスを効率的に管理します。これには、モデルのロード、変換、ライティング、シェーディング、最終的な画面への描画などが含まれます。
- **シェーディング言語のサポート**：GPU（グラフィックス処理ユニット）上で実行されるシェーダープログラムを作成するための言語（例：GLSL for OpenGL, HLSL for DirectX）のサポートが含まれます。シェーダーは、ライティング、シェーディング、ポストプロセスエフェクトなどのグラフィックス効果の実現に不可欠です。
- **リアルタイムインタラクション**：ユーザーの入力に応じたリアルタイムでのグラフィックスの更新が可能です。これにより、ゲームやインタラクティブなシミュレーション、VR/ARアプリケーションなどで応答性の高い体験が提供されます。

## DirectX


DirectXは、Windowsプラットフォーム向けの3Dグラフィックスおよびマルチメディアの開発に使用されるAPIです。DirectXは、3Dレンダリング、テクスチャマッピング、シェーディング、物理シミュレーションなどの機能を提供します。


シェーディング言語はHLSLです。


## OpenGL


OpenGLは、クロスプラットフォームの2Dおよび3DグラフィックスAPIであり、広範なハードウェアとソフトウェア環境で使用されています。OpenGLは、高速かつ高品質なグラフィックスの描画、画面の表示、および画像処理に使用されます。


シェーディング言語はGLSLです。


※ 現在、OpenGLはメンテナンスモードであり、Vulkanへの移行が進んでいます。


## Vulkan


Vulkanは、Khronos Groupによって策定されたオープンスタンダード・ロイヤリティフリー・クロスプラットフォームなリアルタイム3次元コンピュータグラフィックス・コンピュートAPIです。Android、Windows、Linuxなど、さまざまなプラットフォームで利用可能です。


シェーディング言語は、GLSLかHLSLです。


## Metal


Metalは、Appleのプラットフォーム向けのグラフィックスおよびコンピューティングのAPIです。Metalは、高いパフォーマンスと効率を提供し、iOSおよびmacOSデバイス上での3Dグラフィックスの開発に使用されます。


シェーディング言語はMSLです。


# アニメーション


## スキニング・リギング


スキニングは、3Dキャラクターの骨格（スケルトン）にメッシュ（皮膚）を関連付け、骨格の動きに応じてメッシュも動かす技術です。これにより、キャラクターに自然な動きを実現することができます。

- **リギング（Rigging）**：キャラクターに骨格を設定するプロセス。スキニングの前段階として非常に重要です。
- **ウェイトペインティング**：各骨格がメッシュの特定の頂点にどれだけ影響を与えるかを定義するプロセス。リアルな動きを実現するためには、ウェイトの調整がカギとなります。
- **頂点シェーダー**：GPU上で実行されるプログラムで、スキニングの計算を高速に行います。

### ブレンドシェイプ（Blendshape）


ブレンドシェイプは、特定の表情や形状の変化を事前にモデリングしておき、これらを組み合わせることで、キャラクターの表情変化や形状の変化を実現する技術です。

- **基本形状と目標形状**：キャラクターの基本的な形状から、目標とする形状（例えば、笑顔、怒りの表情など）までの変化を定義します。
- **インターポレーション**：基本形状と目標形状の間を滑らかに変化させることで、自然なアニメーションを作り出します。
- **フェイシャルアニメーション**：ブレンドシェイプは特に顔の表情を豊かにするために利用され

## Kinematics (IK/FK) 運動学

1. 逆運動学（IK）がどのようにして末端エフェクタ（手足の先など）の目標位置から、関節の角度を逆算するかの説明。FK（Forward Kinematics、順運動学）との比較を交えて、両者の違いと使い分けについて解説。
2. **IKの応用**：
	- 歩行アニメーション、オブジェクトの把持、キャラクターの身体が自然に曲がる動作など、IKの具体的な使用例を紹介。
	- ゲームや映画でのIKの利用事例を示し、その効果を具体的に説明。
3. **IKソルバー**：
	- IK問題を解決するための数学的アルゴリズムやソルバー（例：CCD (Cyclic Coordinate Descent)、FABRIK (Forward And Backward Reaching Inverse Kinematic)など）について紹介。
	- 使用するソフトウェアやエンジンにおけるIKソルバーの種類と特性。

## シミュレーション

1. **物理ベースのアニメーション**
	- 重力、慣性のシミュレーション
	- 衝突検出と応答
2. **パーティクルシステム**
	- 火、煙、液体のシミュレーション
	- パーティクルの動きと挙動
3. **布や髪の毛のシミュレーション**
	- 布の動きと衝突
	- 髪の毛や毛皮のリアルタイムシミュレーション

# 色空間とカラープロファイル


色空間とは自然界に存在する無限の色を数値的に表現するための規格になります。


![image.png](/images/books/tar/computer_graphics_7.png)




## 主要な色空間の種類

- **sRGB**: 一般的なディスプレイやウェブ用の標準的な色空間
- **Adobe RGB**: 印刷用途に適した広い色域を持つ色空間
- **DCI-P3**: 映画産業で使用される色空間規格
- **Rec.709**: HDTVの標準色空間
- **Rec.2020**: 4K/8K放送用の広色域規格

## カラーマネジメント

- **ICCプロファイル**: デバイス間での色の一貫性を保つための規格
- **色域マッピング**: 異なる色空間間での色の変換方法
- **キャリブレーション**: モニターや出力機器の色調整プロセス

## HDR（High Dynamic Range）

- **明るさのダイナミックレンジ**: より広い輝度範囲の表現
- **HDR規格**: HDR10, Dolby Vision, HLGなど
- **トーンマッピング**: HDRからSDRへの変換技術

## カラースペース変換

- **RGB**: 加法混色による色表現
- **CMYK**: 印刷用の減法混色
- **HSV/HSL**: 色相・彩度・明度による直感的な色指定
- **YUV/YCbCr**: 輝度と色差信号による表現

## ACESについて


ACES（Academy Color Encoding System）は、映画産業で開発された色空間およびカラーマネジメントシステムです。ACESは非常に広い色域と高いダイナミックレンジを持ち、様々な入出力デバイスや色空間間での一貫した色再現を可能にします。このシステムは、撮影から後処理、配信まで、一貫した色管理を実現するワークフローを提供します。


## ガンマ補正


ガンマ補正は、モニターやディスプレイの非線形な輝度特性を補正するために使用される技術です。人間の目は暗い部分の輝度の違いに敏感なため、画像データを表示する際には、適切なガンマ値を使用して明るさを調整する必要があります。一般的なsRGBでは2.2のガンマ値が使用されています。


![image.png](/images/books/tar/computer_graphics_8.png)




## **LUT**


色変換のロジックをテーブル形式で保存したデータ形式のことです。


カラーグレーディングは、本来たくさんのパラメータをつかった計算が必要だが、LUTでは常にその結果のみを参照するので、高速にカラーグレーディングができます。


![image.png](/images/books/tar/computer_graphics_9.png =512x)

    